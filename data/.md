#

## Portada

    • Título del proyecto: Desafío de detección de intrusiones RT-IoT2022
    • Nombre del estudiante / equipo
    • Curso / Taller
    • Fecha
    • Docente

## Índice

    1. Comprensión del Negocio
    2. Comprensión de los Datos
    3. Preparación de los Datos
    4. Modelado
    5. Evaluación
    6. Despliegue (Deployment / Reflexión Final)
    7. Referencias
    8. Anexos (opcional)

1. Comprensión del Negocio
1.1. Contexto general
Describir el contexto de IoT y la importancia de la ciberseguridad en dispositivos conectados.
Ejemplo:
    • Características de las redes IoT.
    • Vulnerabilidades comunes.
    • Necesidad de sistemas de detección de intrusos (IDS).
1.2. Problema a resolver
Definir el problema central:
    • Identificar si un flujo de tráfico IoT es normal o malicioso.
    • Clasificación multicategoría (si se usa Attack_type completo).
1.3. Objetivo del proyecto
El objetivo principal de esta tarea es desarrollar un algoritmo de clasificación utilizando métodos clásicos de aprendizaje automático para distinguir tráfico normal de tráfico malicioso en el dataset RT-IoT2022.
1.4. Métricas de éxito
Especificar cómo se evaluará el modelo:
    • Accuracy
    • Precision
    • Recall
    • F1-Score
    • Matriz de confusión
    • AUC-ROC (si aplica)
2. Comprensión de los Datos
2.1. Descripción del dataset RT-IoT2022
Explicar el origen del dataset:
    • Generado en un testbed controlado
    • Tráfico capturado con Wireshark
    • Dispositivos víctima / atacante
    • Extractores de características: Zeek, CICFlowmeter
2.2. Variables incluidas
Describir brevemente categorías de atributos:
    • Puertos
    • Protocolo / Servicio
    • Duración del flujo
    • Contadores de paquetes
    • Payload
    • IAT (inter-arrival times)
    • Flags TCP
    • Bulk features
    • Window size
    • Attack_type (target)
2.3. Volumen y estructura
    • Número de registros
    • Número de características
    • Balance de clases
    • Primeras filas del dataset (tabla o imagen)
2.4. Análisis exploratorio (EDA)
Incluir gráficos como:
    • Distribución de clases
    • Histogramas
    • Boxplots
    • Matriz de correlación
    • Estadísticas descriptivas
3. Preparación de los Datos
3.1. Selección de atributos
    • Eliminación de columnas irrelevantes
    • Filtrado de atributos redundantes
3.2. Limpieza de datos
    • Manejo de valores faltantes
    • Detección de outliers
    • Correcciones necesarias
3.3. Ingeniería de características
    • Codificación de variables categóricas (LabelEncoder / One-Hot)
    • Normalización / estandarización (StandardScaler, MinMaxScaler)
3.4. División del dataset
Separación en:
    • Train (70–80%)
    • Test (20–30%)
    • Validación (si aplica)
4. Modelado
4.1. Algoritmos seleccionados
Ejemplos de modelos clásicos:
    • Regresión Logística
    • Árbol de decisión
    • Random Forest
    • k-Nearest Neighbors
    • SVM
    • Naïve Bayes
4.2. Justificación de los modelos
Explicar por qué fueron seleccionados:
    • Interpretabilidad
    • Eficiencia
    • Rendimiento esperado en datasets IoT
4.3. Entrenamiento del modelo
Describir:
    • Hiperparámetros utilizados
    • Técnicas de validación cruzada
    • GridSearch o RandomSearch (si se usó)
4.4. Problemas encontrados
Mencionar dificultades típicas:
    • Desbalance de clases
    • Tiempo de entrenamiento
    • Overfitting
    • Requiere mayor preprocesamiento
5. Evaluación
5.1. Métricas obtenidas
Incluir para cada modelo:
Modelo Accuracy Precision Recall F1 ROC-AUC
5.2. Matriz de confusión
Insertar una figura por cada modelo relevante.
5.3. Comparación de modelos
Explicar cuál modelo tuvo mejor rendimiento y por qué.
5.4. Evaluación respecto al objetivo del negocio
    • ¿El modelo detecta ataques adecuadamente?
    • ¿Es lo suficientemente eficiente para IoT?
    • ¿Es aplicable en un entorno real?
6. Reflexión Final
Aunque en un taller académico no se despliega el modelo en producción, esta sección debe contener:
6.1. Conclusiones
    • Logros del proyecto
    • Desempeño final del modelo
    • Aprendizajes
6.2. Recomendaciones
    • Ajustes futuros
    • Pruebas con otros modelos
    • Manejo de clases desbalanceadas
    • Integración con IDS en tiempo real
6.3. Trabajo futuro
    • Probar modelos avanzados (XGBoost, LightGBM, Redes Neuronales)
    • Implementación en Raspberry Pi o microcontroladores
    • Inclusión de técnicas de detección de anomalías
7. Referencias
Lista de fuentes académicas o documentaciones utilizadas.
8. Anexos (opcional)
    • Notebook de Jupyter o GitHub
